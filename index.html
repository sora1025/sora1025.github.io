<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Sora">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Sora">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sora">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Sora</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sora</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/27/XSS攻击/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/27/XSS攻击/" itemprop="url">XSS攻击</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-27T18:29:50+08:00">
                2020-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、什么是XSS？"><a href="#一、什么是XSS？" class="headerlink" title="一、什么是XSS？"></a>一、什么是XSS？</h4><p>XSS全称是Cross Site Scripting即跨站脚本，XSS攻击通常指通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令到页面，使用户<strong>加载并执行攻击者恶意制造的网页程序</strong>。</p>
<h4 id="二、危害"><a href="#二、危害" class="headerlink" title="二、危害"></a>二、危害</h4><ol>
<li>盗取各类用户账号</li>
<li>读取、篡改、添加、删除敏感数据</li>
<li>盗取资料</li>
<li>非法转账</li>
<li>强制发送电子邮件</li>
</ol>
<h4 id="三、XSS类型"><a href="#三、XSS类型" class="headerlink" title="三、XSS类型"></a>三、XSS类型</h4><ol>
<li><strong>持久型跨站</strong></li>
</ol>
<p>持久型XSS，也叫存储型XSS，主要是将XSS代码发送到服务器。最典型的案例是留言板XSS。</p>
<p>用户提交一条包含XSS代码的留言到数据库，当目标用户查看留言板时，留言内容会从数据库查询出来并展示，浏览器发现有XSS代码，会当作正常的HTML与JS解析执行，触发XSS攻击。</p>
<ol start="2">
<li><strong>非持久型跨站</strong></li>
</ol>
<p>非持久型XSS，也叫反射型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。</p>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\\请求URL</span><br><span class="line">http://localhost:8080/helloController/search?name=&lt;script&gt;alert(&quot;hey!&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>此时服务器只做了一个简单的字符串连接就返回给客户端,就会执行script代码。</p>
<h4 id="四、防范手段"><a href="#四、防范手段" class="headerlink" title="四、防范手段"></a>四、防范手段</h4><ol>
<li><strong>入参字符过滤</strong></li>
</ol>
<p>将输入时一些不合法的东西过滤掉，如移除用户上传的style节点，<code>&lt;iframe&gt; &lt;script&gt; &lt;a&gt;</code>节点等。</p>
<ol start="2">
<li><strong>出参进行编码</strong></li>
</ol>
<p>像一些常见符号，如<code>&lt;&gt;</code>在输出时要对其进行转换编码，这样做浏览器就不会对该标签进行解释执行，同时也不会影响显示效果。</p>
<p>例如，对<code>&lt;&gt;</code>做编码：<code>&lt;</code>用<code>&amp;lt;</code>，<code>&gt;</code>用<code>&amp;gt;</code>代替。</p>
<ol start="3">
<li><strong>入参长度限制</strong></li>
</ol>
<p>通过以上的案例我们不难发现XSS攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。</p>
<ol start="4">
<li><strong>设置cookie httponly为true</strong></li>
</ol>
<p>参考博客：</p>
<p><a href="https://www.cnblogs.com/mao2080/p/9460397.html" target="_blank" rel="noopener">网络攻击-XSS攻击详解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/23/TCP为什么是三次握手四次挥手/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/23/TCP为什么是三次握手四次挥手/" itemprop="url">TCP为什么是三次握手四次挥手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-23T19:25:14+08:00">
                2020-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h4><p>关于三次握手的问题，我看了很多博客，但是说法不一，谢希仁著《计算机网络》第四版中，讲“三次握手”的目的是：</p>
<blockquote>
<p>防止已失效的连接请求报文段又传送到服务器端，造成资源的浪费。</p>
</blockquote>
<p>但实际上，这个只能算表因，并不涉及本质。</p>
<h4 id="二、TCP三次握手过程"><a href="#二、TCP三次握手过程" class="headerlink" title="二、TCP三次握手过程"></a>二、TCP三次握手过程</h4><p><strong>TCP报文格式</strong><br><img src="./img/TCP连接/TCP报文格式.png" alt=""></p>
<p><strong>字段含义</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Seq</td>
<td>序列号</td>
<td>用来标识从TCP源端向目的端发送的字节流</td>
</tr>
<tr>
<td>ack</td>
<td>确认号</td>
<td>只有Ack标志位为1时，确认序号字段才有效。ack = Seq + 1，若同意连接，则响应报文中应该使SYN=1，ACK=1</td>
</tr>
<tr>
<td>SYN</td>
<td>标志位</td>
<td>在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文</td>
</tr>
<tr>
<td>FIN</td>
<td>标志位</td>
<td>释放一个新连接,当FIN=1,表明此报文的发送方数据已经发送完毕</td>
</tr>
<tr>
<td>RST</td>
<td>标志位</td>
<td>重置连接</td>
</tr>
<tr>
<td>ACK</td>
<td>标志位</td>
<td>仅当ACK=1时，确认号字段才有效</td>
</tr>
<tr>
<td>URG</td>
<td>标志位</td>
<td>表明紧急指针有效，告诉系统此报文段中有紧急数据</td>
</tr>
<tr>
<td>PSH</td>
<td>标志位</td>
<td>接收方应该尽快将这个报文交给应用层</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：</p>
<ol>
<li>不要将确认序号ack与标志位中的ACK搞混</li>
<li>确认方Ack=发起方Seq+1，两端配对</li>
</ol>
</blockquote>
<p><strong>三次握手过程</strong><br><img src="./img/TCP连接/TCP三次握手过程.png" alt=""></p>
<h4 id="三、为什么TCP需要握手这个操作"><a href="#三、为什么TCP需要握手这个操作" class="headerlink" title="三、为什么TCP需要握手这个操作"></a>三、为什么TCP需要握手这个操作</h4><p>在解答为什么TCP需要三次握手，而不是两次之前，首先需要回答的问题是：<strong>为什么需要握手这个操作，能不能不握手？</strong></p>
<p>这里引出了TCP和UDP的一个基本区别：TCP是可靠通信协议，而UDP是不可靠通信协议。</p>
<ul>
<li>TCP的可靠性含义：接收方收到的数是<strong>完整</strong>、<strong>有序</strong>、<strong>无差错</strong>的。</li>
<li>UDP不可靠性含义：接收方接收到的数据可能存在部分丢失，顺序也不一定能保证。</li>
</ul>
<p><strong>TCP可靠传输的精髓</strong></p>
<p>TCP协议为了实现可靠传输，通信双方需要判断自己已经发送的数据包是否都被接收方收到，如果没收到，就需要重新发送。因此，为了实现这个需求。就引出<strong>序号Seq</strong>和<strong>确认号Ack</strong>的使用。</p>
<p>发送方在发送数据包(假设大小为10byte)，同时会发送一个<strong>序列号</strong>(假设为500)，那么接收方收到这个数据包以后，就回复一个<strong>确认号</strong>(500+10=510),告诉发送方：“我已经收到了你的数据包，你可以发送下一个数据包，序号从510开始。”</p>
<p>这样发送方就可以知道哪些数据被接收到，哪些数据没被接收到，需要重发。</p>
<h4 id="四、为什么TCP是三次握手？"><a href="#四、为什么TCP是三次握手？" class="headerlink" title="四、为什么TCP是三次握手？"></a>四、为什么TCP是三次握手？</h4><p>总结上文内容，一句话概括，<strong>TCP连接握手，握的是什么？</strong></p>
<p><strong>是通信双方数据原点的序列号！</strong></p>
<h4 id="五、为什么TCP是四次挥手"><a href="#五、为什么TCP是四次挥手" class="headerlink" title="五、为什么TCP是四次挥手"></a>五、为什么TCP是四次挥手</h4><p>因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和FIN放在一个报文中发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据。此时，服务端也未必将全部数据都发送给对方了。所以我们可以不必立即close，也可以发送一些数据，再发送FIN报文给对方来表示同意现在关闭连接。所以在关闭连接时，FIN和ACK是分开发送的。<br><img src="./img/TCP连接/TCP四次挥手过程.png" alt=""></p>
<p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">参考的是知乎的回答</a></p>
<p>图源自网络，侵删道歉</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/21/typeof和instanceof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/21/typeof和instanceof/" itemprop="url">typeof和instanceof</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-21T22:48:43+08:00">
                2020-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>我们可以利用<code>typeof</code>来判断<code>number</code>,<code>string</code>,<code>object</code>,<code>boolean</code>,<code>function</code>,<code>undefined</code>,<code>symbol</code>这7种类型。但<code>typeof</code>在判断一个<code>object</code>的数据时候只能判断这个数据是<code>object</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s1 = new String(&apos;abc&apos;)</span><br><span class="line">console.log(typeof(s1)) //object</span><br><span class="line">//不过以字面量形式创建是可以判断的</span><br><span class="line">let s2 = &apos;abc&apos;</span><br><span class="line">console.log(s2) //string</span><br></pre></td></tr></table></figure></p>
<h4 id="instanceof-实现原理"><a href="#instanceof-实现原理" class="headerlink" title="instanceof 实现原理"></a>instanceof 实现原理</h4><p><code>instanceof</code>的主要作用是判断一个实例是否属于某种类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let person = function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">let sora = new person()</span><br><span class="line">sora instanceof person //true</span><br></pre></td></tr></table></figure></p>
<p><strong>instance的主要实现原理就是只要右边变量的prototype在左边变量的原型链上即可。所以instance在查找过程中会遍历左边变量的原型链，找到即返回true，失败则会返回false</strong>，告诉我们左边变量不是右边变量的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//代码实现</span><br><span class="line">function myInstanceOf(left,right)&#123;</span><br><span class="line">    //null是原型链的终点</span><br><span class="line">    //null instanceof Object --&gt;false</span><br><span class="line">    if(left == null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let rightPrototype = right.prototype;</span><br><span class="line">    let leftProto = left.__proto__;</span><br><span class="line">    if(leftProto == rightPrototype)&#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是<code>instanceof</code>也并不是最准确的判断方法,比如一个数组，也可以被判定为Object类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3] instanceof Object //true</span><br><span class="line">[1,2,3] instanceof Array // true</span><br></pre></td></tr></table></figure></p>
<p>同样字符串也是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = new String(&apos;123&apos;);</span><br><span class="line">str instanceof Object //true</span><br><span class="line">str instanceof String //true</span><br></pre></td></tr></table></figure></p>
<h4 id="一个更准确的判断方法"><a href="#一个更准确的判断方法" class="headerlink" title="一个更准确的判断方法"></a>一个更准确的判断方法</h4><p>以上两种方法并不是最准确的判断变量类型的方法，下面介绍一种JS中较为准确的类型判断方法<code>Object.prototype.toString.call</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(1) // &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&apos;hi&apos;) // &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;a:&apos;hi&apos;&#125;) // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([1,&apos;a&apos;]) // &quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(() =&gt; &#123;&#125;) // &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null) // &quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(Symbol(1)) // &quot;[object Symbol]&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof null //Object</span><br><span class="line">null instanceof Object  //false</span><br><span class="line">null instanceof null    //typeError</span><br><span class="line">Object.prototype.toString.call(null) // [object Null]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>null有时会被当成一种对象类型，但是这是语言本身的bug，实际上，null是基本类型</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单来说，我们使用<code>typeof</code>来判断基本数据类型是ok 的，不过需要注意当用<code>typeof</code>来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用<code>instanceof</code>，但是<code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被<code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取<code>Object.prototype.toString.call</code> 方法。</p>
<p><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">参考博客：浅谈instanceof和typeof的实现原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/原型的重写/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/20/原型的重写/" itemprop="url">原型的重写</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-20T20:06:30+08:00">
                2020-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>上一篇文章讲了原型和原型链的基础知识，这篇文章我们学习原型的重写。</p>
<h4 id="通过例子来理解"><a href="#通过例子来理解" class="headerlink" title="通过例子来理解"></a>通过例子来理解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//例子1</span><br><span class="line">Person.prototype.name = &apos;sora&apos;;</span><br><span class="line">function Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">Person.prototype.name = &apos;sora&apos;;</span><br><span class="line">//person.name --&gt; sora</span><br></pre></td></tr></table></figure>
<p>这和上一篇文章的例子相同。那我们换一种写法，看看输出什么结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//例子2</span><br><span class="line">Person.prototype.name = &apos;sora&apos;;</span><br><span class="line">function Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">Person.prototype.name = &apos;yangning&apos;</span><br><span class="line">//person.name --&gt; yangning</span><br></pre></td></tr></table></figure></p>
<p>只是换了种写法，就输出了截然不同的结果。为什么呢？其实很好理解，我们作以下区分</p>
<p><strong>person.prototype.name是修改原有原型的属性，而下面的那种写法，是把它的原型整个换掉，换了个新对象</strong>。<br>上面的例子我们很好理解，那么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//例子3</span><br><span class="line">Person.prototype.name = &apos;sora&apos;;</span><br><span class="line">function Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name:&apos;yangning&apos;</span><br><span class="line">&#125;</span><br><span class="line">//person.name --&gt;sora</span><br><span class="line">//Person.prototype说：我不干了，我要换一个指向空间，可是此时__proto__还坚守在原地，并没有改变</span><br></pre></td></tr></table></figure></p>
<p>好了，接下来我们再变一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//例子4</span><br><span class="line">Person.prototype.name = &apos;sora&apos;;</span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">     name:&apos;yangning&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> var person = new Person();</span><br><span class="line">//peron.name --&gt; yangning</span><br></pre></td></tr></table></figure></p>
<p>这里要考虑语句执行顺序问题。考虑预编译环节，第二行代码的声明会提升到最上面。最后一行new了一个新的对象，new的时候函数才会出现第三行代码的变化。所以第四行其实是覆盖掉了第一行代码。而上个例子。person已经被生成了。<strong>其实就是生成实例前修改原型和生成实例后修改原型的区别。</strong></p>
<blockquote>
<p>重写原型对象切断了现有原型和任何之前已经存在的对象实例的关系，它们引用的还是最初的原型。参见上面的例子3</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/prototype和-proto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/20/prototype和-proto/" itemprop="url">prototype和__proto__</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-20T19:45:49+08:00">
                2020-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h4><p>这段时间会更新一系列原生JS的知识点，一是巩固基础，二是为了春招做准备。现在回过头看自己以前学习做的笔记，能发现很多错误，一些不懂的地方现在也有新的感悟。所谓温故而知新的道理吧。</p>
<h4 id="二、prototype"><a href="#二、prototype" class="headerlink" title="二、prototype"></a>二、prototype</h4><p><code>prototype</code>是<strong>函数</strong>对象的一个属性，指向该函数的原型对象。这个属性是一个指针，指向一个对象。这个对象包含所有其实例共享的实例和方法。即上文所说原型对象。</p>
<p>通过这个属性，我们可以实现<strong>基于原型的继承</strong>和属性的共享。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//举个例子，多动手</span><br><span class="line">function Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &apos;sora&apos;;</span><br><span class="line">let p = new Person();</span><br><span class="line">console.log(p.name);    //sora</span><br></pre></td></tr></table></figure></p>
<h4 id="三、proto"><a href="#三、proto" class="headerlink" title="三、proto"></a>三、<strong>proto</strong></h4><p><code>__proto__</code>是隐式原型，每个对象都会在其内部初始化一个属性构成原型链，同样是用于实现<strong>基于原型的继承</strong>。还是用上面的例子理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &apos;sora&apos;;</span><br><span class="line">let p = new Person();</span><br><span class="line">console.log(p.name);    //sora</span><br></pre></td></tr></table></figure></p>
<p>我们试图打印p的name属性，可是p对象内部并不存在这个属性。那么我们就会通过它的<code>__proto__</code>属性向上找，直到找到为止。那么<code>__proto__</code>属性，指向的是什么呢？</p>
<blockquote>
<p>请记住一句话：<strong>proto</strong>指向它构造器的原型。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//举个例子</span><br><span class="line">function a() &#123;</span><br><span class="line">    //console.log(&quot;I&apos;am a function.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//b是实例化对象，a其构造器</span><br><span class="line">var b = new a();</span><br><span class="line">//翻译这个打印结果：b的__proto指向它构造器(a)的原型(prototype)</span><br><span class="line">console.log(b.__proto__ == a.prototype);  //true</span><br></pre></td></tr></table></figure>
<p>另外要注意一点：</p>
<blockquote>
<p>（<strong>proto</strong>并非标准属性，ECMA-262第5版将该属性或指针称为[[Prototype]]，可通过Object.getPrototypeOf()标准方法访问该属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(b) == a.prototype);  //true,标准方法返回的结果和上述一样</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="三、我是例子"><a href="#三、我是例子" class="headerlink" title="三、我是例子"></a>三、我是例子</h4><p>为了更好的理解<code>prototype</code>和<code>__proto__</code>的关系，我们通过一些例子来理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.name = &quot;sora&quot;</span><br><span class="line">let p = new Person()</span><br><span class="line"></span><br><span class="line">console.log(Person.prototype) //     a&#123; name:&apos;sora&apos; &#125;</span><br><span class="line">console.log(Person.__proto__) //  [Function]</span><br><span class="line"></span><br><span class="line">console.log(p.__proto__)    // a&#123; name:&apos;sora&apos; &#125;，指向它构造器Person的原型</span><br><span class="line">console.log(p.prototype)    //undefined,函数才有prototype属性哟</span><br></pre></td></tr></table></figure></p>
<h4 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h4><ol>
<li><p><code>prototype</code>属性可以给对象添加可共享(继承)的方法、属性。而<code>__proto__</code>是查找某函数的原型链方式。</p>
</li>
<li><p><code>prototype</code>是构造函数访问原型对象，<code>__proto__</code>是对象实例访问原型对象</p>
</li>
</ol>
<h4 id="五、当我们在new一个对象时，我们在做什么"><a href="#五、当我们在new一个对象时，我们在做什么" class="headerlink" title="五、当我们在new一个对象时，我们在做什么"></a>五、当我们在new一个对象时，我们在做什么</h4><p>当执行new func的时候，执行过程如下：</p>
<ol>
<li>首先创建一个新的空对象，<code>obj</code></li>
<li><code>obj.[[prototype]] = func.prototype</code></li>
<li>执行构造函数中的代码，构造函数中的<code>this</code>指向该对象</li>
<li>返回对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//举个例子</span><br><span class="line">var Person = function(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.show = function()&#123;</span><br><span class="line">    console.log(this.name,this.age);</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&quot;sora&quot;,20);</span><br><span class="line">//相当于</span><br><span class="line">var p = &#123;&#125;;</span><br><span class="line">p.__proto__ = Person.prototype;</span><br><span class="line">Person.call(p,&quot;sora&quot;,20);</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/原生JS实现AJAX详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/15/原生JS实现AJAX详解/" itemprop="url">原生JS实现AJAX详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-15T19:09:32+08:00">
                2020-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、什么是AJAX"><a href="#一、什么是AJAX" class="headerlink" title="一、什么是AJAX"></a>一、什么是AJAX</h4><p>Ajax是一种异步请求数据的web开发技术，在不需要刷新页面的情况下，Ajax通过异步请求加载后台数据，并在网页上呈现出来。</p>
<h4 id="二、AJAX使用场景"><a href="#二、AJAX使用场景" class="headerlink" title="二、AJAX使用场景"></a>二、AJAX使用场景</h4><ol>
<li>局部刷新</li>
<li>表单验证(最初的设计目的)</li>
<li>无刷新动态获取数据</li>
</ol>
<h4 id="三、使用AJAX请求数据流程"><a href="#三、使用AJAX请求数据流程" class="headerlink" title="三、使用AJAX请求数据流程"></a>三、使用AJAX请求数据流程</h4><ol>
<li>创建一个AJAX对象xhr</li>
<li>打开地址</li>
<li>发送</li>
<li>等待响应数据</li>
<li>回调函数处理</li>
</ol>
<h4 id="四、AJAX的状态有哪些"><a href="#四、AJAX的状态有哪些" class="headerlink" title="四、AJAX的状态有哪些"></a>四、AJAX的状态有哪些</h4><p>0-未初始化，尚未调用open()方法</p>
<p>1-启动，调用send()方法，正在发送请求</p>
<p>2-发送，已调用send()方法，已接受到响应</p>
<p>3-解析，正在解析响应数据</p>
<p>4-完成，响应数据解析完成，客户端可以调用<br><code>xhr.readyState == 4</code></p>
<h4 id="五、封装AJAX"><a href="#五、封装AJAX" class="headerlink" title="五、封装AJAX"></a>五、封装AJAX</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">function myAjax(options)&#123;</span><br><span class="line">  //调用函数时如果options没有指定，就给它赋值&#123;&#125;，一个空的Object</span><br><span class="line">  options = options || &#123;&#125;; </span><br><span class="line">  //请求格式GET、POST，默认为GET</span><br><span class="line">  options.type = (options.type || &quot;GET&quot;).toUpperCase();</span><br><span class="line">  //响应数据格式，默认json</span><br><span class="line">  options.dataType = options.dataType || &quot;json&quot;</span><br><span class="line">  let params = formatParams(options.data);</span><br><span class="line">  let xhr;</span><br><span class="line">  if(window.XMLHttpRequest)&#123;</span><br><span class="line">    xhr = new XMLHttpRequest();</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    //兼容IE6以下版本</span><br><span class="line">    xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(options.type == &quot;GET&quot;)&#123;</span><br><span class="line">    //参数3是布尔值，默认是false异步，true同步</span><br><span class="line">    xhr.open(&quot;GET&quot;,options.url+&quot;?&quot;+params);</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;else if(options.type == &quot;POST&quot;)&#123;</span><br><span class="line">    xhr.open(&quot;POST&quot;,options.url);</span><br><span class="line">    //设置表单提交时的内容类型</span><br><span class="line">    xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">    xhr.send(params);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //设置有效时间</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">    if(xhr.readystate != 4)&#123;</span><br><span class="line">      xhr.abort()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,options.timeout)</span><br><span class="line"></span><br><span class="line">  //接收</span><br><span class="line">  xhr.onreadystatechange = function()&#123;</span><br><span class="line">    if(xhr.readystate == 4)&#123;</span><br><span class="line">      let status = xhr.status;</span><br><span class="line">      if(status&gt;=200 &amp;&amp; status&lt;= 300)&#123;</span><br><span class="line">        options.sucess(xhr.responseText,xhr.responseXML);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        options.error(status)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //格式化请求参数</span><br><span class="line">  function formatParams(data)&#123;</span><br><span class="line">    let arr = [];</span><br><span class="line">    for(var name in data)&#123;</span><br><span class="line">      arr.push(encodeURIComponent(name)+&quot;=&quot;+encodeURIComponent(data[name]));</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push((&quot;v=&quot;+Math.random()).replace(&quot;.&quot;,&quot;&quot;));</span><br><span class="line">    return arr.join(&quot;&amp;&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="六、使用实例"><a href="#六、使用实例" class="headerlink" title="六、使用实例"></a>六、使用实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">myAjax(&#123;</span><br><span class="line">        url:&quot;http://server-name/login&quot;,</span><br><span class="line">        type:&apos;post&apos;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            username:&apos;username&apos;,</span><br><span class="line">            password:&apos;password&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        dataType:&apos;json&apos;,</span><br><span class="line">        timeout:10000,</span><br><span class="line">        contentType:&quot;application/json&quot;,</span><br><span class="line">        success:function(data)&#123;</span><br><span class="line">　　　　　　。。。。。。//服务器返回响应，根据响应结果，分析是否登录成功</span><br><span class="line">        &#125;,</span><br><span class="line">        //异常处理</span><br><span class="line">        error:function(e)&#123;</span><br><span class="line">            console.log(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>搬运博客：<a href="https://www.cnblogs.com/qing-5/p/11368009.html" target="_blank" rel="noopener">原生JS实现AJAX封装</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/只出现一次的数字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/10/只出现一次的数字/" itemprop="url">只出现一次的数字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-10T15:09:50+08:00">
                2020-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</p>
<p>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>看到这道题目，脑子里第一个想的就是循环比较，但是看了题解，发现异或这种做法。</p>
<p>异或运算符主要是在位运算时使用，也可以用于十进制数，但其实中间有一个转换过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = 1^2 //3</span><br><span class="line">//转换过程</span><br><span class="line">//1 -&gt; 01</span><br><span class="line">//2 -&gt; 10</span><br><span class="line">//1^2 -&gt; 11 -&gt;3</span><br></pre></td></tr></table></figure></p>
<p>关于异或这种解法，首先有几个数学知识要掌握：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 交换律：a^b^c &lt;=&gt; a^c^b</span><br><span class="line">2. 任何数异或0为任何数：n^0 &lt;=&gt; n</span><br><span class="line">3. 相同数异或为0: n^n</span><br></pre></td></tr></table></figure></p>
<p>掌握了这些知识，这道题就迎刃而解了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var singleNumber = function(nums) &#123;</span><br><span class="line">    let res = 0;    //0与任何数异或为任何数</span><br><span class="line">    for(let i = 0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        res^=nums[i]; //如果之后出现相同的数结果就会为0，继续进行异或操作</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/域名收敛和域名发散/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/09/域名收敛和域名发散/" itemprop="url">域名收敛和域名发散</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-09T14:52:21+08:00">
                2020-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>今天在学习过程中看到一个名词：<strong>域名收敛</strong>。感觉好高大上，没听过。于是便去学习了一下，参考了好几篇博客，自己整理了一下知识点。文末会放上参考博客链接！</p>
<h4 id="域名发散"><a href="#域名发散" class="headerlink" title="域名发散"></a>域名发散</h4><p>由于浏览器的限制，每个浏览器，允许对每个域名的连接数一般是有上限的。一般来说浏览器内每个hostname的最大连接数基本是6个，总体而言并发数不高。所以PC时代为了突破浏览器的域名并发限制，遵循这样一条定律：</p>
<blockquote>
<p>http静态资源采用多个子域名</p>
</blockquote>
<p>目的是充分利用现代浏览器的<strong>多线程并发下载能力</strong>。所以PC时代对静态资源优化时，通常将静态资源分布在几个不同域，保证资源最完美地分域名存储。</p>
<h4 id="域名收敛"><a href="#域名收敛" class="headerlink" title="域名收敛"></a>域名收敛</h4><p>域名收敛就是建议将静态资源只放在一个域名下面，而非发散情况下的多个域名下。可是上面说了，域名发散可以提高并发下载能力，为什么这里又提倡域名收敛？是因为域名发散是PC时代的产物，对于PC上的DNS通常情况下就是几十ms，因为PC可以存储很多的域名地址。但现在进入移动互联网时代，对于手机端来说，一般在手机端解析DNS会到1s+，首屏的3s的最佳时间，已经没了1/3.</p>
<p>所以一般来说，<strong>在手机端上的域名数不能超过5个</strong>。基本的分配就是</p>
<p>HTML +1</p>
<p>CSS +1</p>
<p>img +1</p>
<p>JS +1</p>
<p>fonts +1</p>
<p>不过也得看具体应用场景</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>DNS解析是一个很复杂的过程，在PC上，我们采用域名发散策略，是因为在PC端上，DNS解析通常只需要几十ms。而移动端，2G网络，3G网络，4G网络/wifi强网，DNS的消耗相当可观。在增加域的同时，往往会给浏览器带来DNS解析的开销。所以在这种情况下，提出了域名收敛，减少域名数量可以降低DNS解析的成本。</p>
<p>传送门一：<a href="https://segmentfault.com/a/1190000004641599" target="_blank" rel="noopener">域名收敛–前端优化(二)</a></p>
<p>传送门二：<a href="https://www.cnblogs.com/coco1s/p/5365179.html" target="_blank" rel="noopener">【前端性能】浅谈域名发散与域名收敛</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/04/把一个对象拆分成多个对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/把一个对象拆分成多个对象/" itemprop="url">把一个对象拆分成多个对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T18:03:49+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近做项目有用到Element-UI中的Table组件，但是比较麻烦的是，我需要用到几行共用一个数据。需要对后台传过来的数据进行一下处理。简单地来说就是像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//原来的数据</span><br><span class="line">var obj1 = [</span><br><span class="line">    &#123;</span><br><span class="line">        a:&quot;01&quot;,</span><br><span class="line">        b:[&quot;1&quot;,&quot;2&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        a:&quot;02&quot;,</span><br><span class="line">        b:[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//我想得到下面的这个数组</span><br><span class="line">var obj2 = [</span><br><span class="line">    &#123;</span><br><span class="line">        a:&quot;01&quot;,</span><br><span class="line">        b:[&quot;1&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        a:&quot;01&quot;,</span><br><span class="line">        b:[&quot;2&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        a:&quot;01&quot;,</span><br><span class="line">        b:[&quot;3&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        a:&quot;01&quot;,</span><br><span class="line">        b:[&quot;4&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        a:&quot;01&quot;,</span><br><span class="line">        b:[&quot;5&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>就是遍历属性b的值，创建新的对象，每个对象的属性b依次赋值。一开始想到的是最笨的方法。其实遇到这个问题，我感觉到遇到问题，一个人第一个想到的解决方法最能看出来这个人的功底。我的功底还远远不够，最近一直在看ES6，但是根本没运用上。感觉真的很像高中数学，光看书是没用的，实践大于理论。</p>
<p>emmm题外话扯远了，看看我第一次考虑时候的问题吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a:&quot;01&quot;,</span><br><span class="line">    b:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span><br><span class="line">&#125;</span><br><span class="line">function tear(obj)&#123;</span><br><span class="line">    let arr = obj.b;</span><br><span class="line">    let Arr = [];</span><br><span class="line">    for(let i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        obj.b = arr[i];</span><br><span class="line">        console.log(obj);</span><br><span class="line">        Arr.push(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return Arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tear(obj));</span><br></pre></td></tr></table></figure></p>
<p>这个方法乍一看是最常规的思路，遍历obj的属性b，然后依次重写赋值。然鹅我们在控制台里打印的是这个东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; a: &apos;01&apos;, b: &apos;1&apos; &#125;</span><br><span class="line">&#123; a: &apos;01&apos;, b: &apos;2&apos; &#125;</span><br><span class="line">&#123; a: &apos;01&apos;, b: &apos;3&apos; &#125;</span><br><span class="line">[ &#123; a: &apos;01&apos;, b: &apos;3&apos; &#125;, &#123; a: &apos;01&apos;, b: &apos;3&apos; &#125;, &#123; a: &apos;01&apos;, b: </span><br><span class="line">&apos;3&apos; &#125; ]</span><br></pre></td></tr></table></figure></p>
<p>我们在一个打印处可以拿到重新修改过的obj，但是为什么打印出存放最终结果的数组，属性值全部变成数组最后一项的值了？</p>
<p>其实是我们遍历的时候<code>obj.b=arr[i]</code>这一行，每一次都会修改obj.b的值。而push()方法push的不是值，而是指向对象的指针，在原对象上修改，值会改变。所以最后打印出来，obj的值都变成了我们最后赋值的那个b。</p>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>然后就去万能的度娘了，不过不知道是不是因为我的搜索词写得不那么准确，相关回答很少，找了很久，才终于找到一个靠谱的。运行一下，居然成了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const arr = &#123;</span><br><span class="line">  opinionVO: [</span><br><span class="line">    &#123;a: &apos;&apos;, b: [1,2,3], c: 10047&#125;,</span><br><span class="line">    &#123;a: &apos;&apos;, b: [4,5,6], c: 10047&#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const result = &#123;</span><br><span class="line">  ...arr,</span><br><span class="line">  opinionVO: arr.opinionVO.reduce((res, item) =&gt; res.concat(...item.b.map(b =&gt; (&#123;...item, b&#125;))), []),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure></p>
<p>乍一看没看懂，这种长长的链式结构真的太不友好了。。。问了菠萝，菠萝说这种写法摆在业务里是要被那啥的。arr.reduce()方法之前没接触过，还有最后为什么是返回多个对象组成的数组，哪里有新建对象了。非常的懵懂，看了一天好像也没怎么弄懂，只是大致知道它做了什么。然后晚上就问了zz和红莲，终于弄懂了。。下面整理一下这串长代码里涉及到的ES6知识点。</p>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><blockquote>
<p>扩展运算符(spread)是三个点(…)，它如同rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//看一个例子</span><br><span class="line">console.log(...[1,2,3])</span><br><span class="line">// 1 2 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这个例子说明了…最简单的用法：将一个数组变成参数序列。那么在那段ES6代码中，我把…arr打印出来，结果会是什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = &#123;</span><br><span class="line">  opinionVO: [</span><br><span class="line">    &#123;a: &apos;&apos;, b: [1,2,3], c: 10047&#125;,</span><br><span class="line">    &#123;a: &apos;&apos;, b: [4,5,6], c: 10047&#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line">//尝试打印...arr</span><br><span class="line">console.log(...arr);</span><br></pre></td></tr></table></figure></p>
<p>(图片一)<br>显示图示报错信息。为什么不能直接打印出来呢？我们可以这样考虑，如果把这个对象变成参数序列，打印出来的是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opinionVO:&#123;</span><br><span class="line">    &#123;a: &apos;&apos;, b: [1,2,3], c: 10047&#125;,</span><br><span class="line">    &#123;a: &apos;&apos;, b: [4,5,6], c: 10047&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样看是不是少了什么？可以直接这样打印吗。没错，就是少了一个{}，我们把上述代码改成这样就可以成功打印了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const arr = &#123;</span><br><span class="line">  opinionVO: [</span><br><span class="line">    &#123;a: &apos;&apos;, b: [1,2,3], c: 10047&#125;,</span><br><span class="line">    &#123;a: &apos;&apos;, b: [4,5,6], c: 10047&#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line">const result = &#123;</span><br><span class="line">    ...arr</span><br><span class="line">&#125;</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure></p>
<p>这样一来我们可以成功打印出结果了。我们再看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//wrong</span><br><span class="line">var obj = &#123;a:1,b:2&#125;;</span><br><span class="line">console.log([...obj]);</span><br><span class="line"></span><br><span class="line">//right</span><br><span class="line">var obj = &#123;a:1,b:2&#125;;</span><br><span class="line">console.log(&#123;...obj&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>reduce(fn,initValue)方法接受两个参数，第一个是对数组每项元素进行处理的回调函数，initValue是累加器的初值。没有时，累加器第一次的值为currentValue。</p>
<p>fn接受4个参数，分别是</p>
<p><strong>accumulator</strong>累加器，即函数上一次调用的返回值。初值为<code>initValue || arr[0]</code><br><br><strong>currentValue</strong>数组中正在处理的值。初值为<code>initValue || arr[1]</code><br><br><strong>currentIndex</strong>(可选)数组中正在处理的值的索引<br><br><strong>array</strong>函数调用的数组</p>
<p>这些基础知识我们知道了以后，再看上面那段ES6代码，相当于是对opinionVo数组的每个元素进行处理。res.concat()相当于把每次的返回值连接起来。就得到了一个由对象组成的新数组。那么问题来了，为什么是返回对象呢？原代码中最让我理解不了的就是这里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b =&gt; (&#123;...item, b&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这就返回对象了？我知道map()方法是对数组中每个元素进行修改，并返回修改后新数组。经过询问，终于得出了答案。…item列出了opinionVO的元素，原来的b会被修改后的b覆盖(所以必须同名，不然就会在对象后面新增加一个b)。而为什么{}外面会有()呢？是因为为了避免歧义。如果我们在箭头函数后面返回一个{a:123}，浏览器会认为这是一个函数。所以我们要在前面加一个()，说明它是一个对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/25/深入理解闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sora">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sora">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/深入理解闭包/" itemprop="url">深入理解闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T20:13:08+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近买了本新书，《你不知道的JS》，听说是书中良品，我觉得写得很好，所以这段时间一直在复习回顾知识点，打算在十一结束之前把三本书看完。这里会记下来原来不是很清楚的知识点。</p>
<h4 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h4><p>首先来看看书中给的定义：<strong>当函数可以记住并访问所在的词法作用域时，就产生了闭包</strong>。</p>
<h4 id="闭包的运用"><a href="#闭包的运用" class="headerlink" title="闭包的运用"></a>闭包的运用</h4><p>解决变量的私有化问题.</p>
<p>下面举个例子说明闭包的实际运用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//计数器 每次调用+1</span><br><span class="line">function add()&#123;</span><br><span class="line">    var counter=0;//局部变量</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line">add();//counter 1</span><br><span class="line">add();//counter 1</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var counter=0;//全局变量</span><br><span class="line">function add()&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line">add();//counter 1</span><br><span class="line">add();//counter 2</span><br></pre></td></tr></table></figure>
<p>改动一下虽然实现了计数器的功能，但是使用全局变量意味着在任何一个地方都可以修改和使用。如果新增一个函数，里面的变量恰好又叫counter，那就全乱套了。</p>
<blockquote>
<p>我们引入闭包，使变量既有全局变量的生命周期，又有局部变量的局部私有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function add()&#123;</span><br><span class="line">    var counter=0;//局部变量</span><br><span class="line">    function plus()&#123;</span><br><span class="line">        counter++;//全局变量的生命周期；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下面只要实现调用plus()函数就是可以了</span><br><span class="line"></span><br><span class="line">------------------------我是分隔符-----------------------</span><br><span class="line">//方法一</span><br><span class="line">function add()&#123;</span><br><span class="line">    var counter=0;</span><br><span class="line">    //全局函数</span><br><span class="line">    plus=function()&#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add();//初始化counter</span><br><span class="line">plus();</span><br><span class="line">plus();</span><br><span class="line"></span><br><span class="line">//方法二</span><br><span class="line">function add()&#123;</span><br><span class="line">    var counter=0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var plus=add();</span><br><span class="line">plus();</span><br><span class="line">plus();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>我们再来进行优化，我们发现上面的add()函数似乎只是用来初始化counter，没有其他的作用，那么下面我们引入<strong>立即执行函数</strong>。</p>
<blockquote>
<p>函数的立即执行：函数声明和函数执行放在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//(add)()</span><br><span class="line"></span><br><span class="line">var plus = (function /*add*/()&#123;</span><br><span class="line">    var counter=0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">//写/*add*/是想说明这里可以去掉，但是为了和上面的代码进行对比，比较容易看懂，我在这里保留</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h4><p>我们先上一个栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i&lt;=5;i++)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;,i*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们写这段代码的本意是让它输出1-5，每秒一次，每次一个数字。而实际上，运行这段代码，会看到终端每秒输出一个6，输出五次。那么，为什么会输出5个6？</p>
<p>这是首先涉及到延时函数的执行机制。我们来看这段代码：timer()收到命令，1s后执行，在这个过程中，程序不是阻塞的，会先执行for循环代码，也就是等for循环结束后，延时函数才开始执行。循环结束时，此时i=6,所以会打印出5个6。那为什么是5个6呢？for()循环每执行一次就会创建一个延时函数，它们共享一个作用域。</p>
<p>所以解决方案是：每循环一次，创建一个作用域，立即执行一个延时函数。 我们首先想到的是立即执行函数(IIFE)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i&lt;=5;i++)&#123;</span><br><span class="line">   (function() &#123;</span><br><span class="line">       setTimeout(function timer()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;,i*1000);</span><br><span class="line">   &#125;)();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在终端打印出来，发现还是5个6！问题出在哪里？IIFE虽然会创建一个新的作用域，但是它是一个什么都没有的空作用域，所以每次还是会引用处于全局作用域的i。所以它需要有自己的变量，用来在每个迭代中存储i的值，再来改进一下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i&lt;=5;i++)&#123;</span><br><span class="line">   (function() &#123;</span><br><span class="line">       var j =i;</span><br><span class="line">       setTimeout(function timer()&#123;</span><br><span class="line">        console.log(j);</span><br><span class="line">    &#125;,j*1000);</span><br><span class="line">   &#125;)();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样在控制台中打印出来的就没问题了。我们可以对这段代码进行进一步的改进：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i&lt;=5;i++)&#123;</span><br><span class="line">   (function(j) &#123;</span><br><span class="line">       setTimeout(function timer()&#123;</span><br><span class="line">        console.log(j);</span><br><span class="line">    &#125;,j*1000);</span><br><span class="line">   &#125;)(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们继续思考，其实解决上述问题的关键在于每次迭代要创建一个新的块作用域。既然如此，ES6中规定的let声明也可以派上用场！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i=1;i&lt;=5;i++)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;,i*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>书中说for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次。每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时候就产生了闭包。</p>
<p>啊~被这个问题折磨了好久。还有一篇相关好文推荐，面试时候可以看看，tql，<a href="https://zhuanlan.zhihu.com/p/25407758" target="_blank" rel="noopener">闭包面试题</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sora</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sora</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
